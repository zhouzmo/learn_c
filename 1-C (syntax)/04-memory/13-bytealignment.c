#include <stdio.h>

typedef struct stu
{
   char sex;
   int age;
}stu;


/*
字节对齐
字节对齐：补空成，类型最大的元素 的整数倍 -> 空间换时间(避免读两次来拼接数据)


结构体是由多个成员变量组成的数据类型，
其大小需要满足两个要求：成员变量在内存中的存储顺序与结构体定义时的顺序相同；
每个成员变量需要按照某种规则进行对齐，以保证访问数据时的效率和正确性。
在 C 语言中，经常使用的数据类型有 char、short、int、long 等等，它们的大小可能不同，
比如 char 的大小是 1 字节，而 int 的大小通常是 4 字节（32 位系统）或 8 字节（64 位系统）。
为了避免结构体中的较小成员变量被分配到跨度很长的内存区域中，导致内存占用率高，CPU 访问速度慢的问题
，C 语言引入了内存对齐的概念。

当定义一个结构体时，编译器会按照特定的对齐规则来确定结构体中每个成员变量的存储位置。
C 语言中的对齐规则是：每个成员变量的地址必须是其数据类型字节数的整数倍
（例如，int 类型的变量必须从 4 字节边界开始存储）。如果成员变量的地址不符合这个规则，
编译器会在成员变量之后填充一些无用字节，以使下一个成员变量能够按照对齐规则存储。
对于一个结构体的大小，需要考虑每个成员变量所占用的空间（不包括填充字节）之和。
由于补齐字节也算作结构体的一部分，在计算结构体大小时也要考虑补齐字节的数量。
因此，在某些情况下，我们会看到结构体在计算大小时需要进行补齐的情况。
一般情况下，补齐的字节数是结构体中最大的成员变量的大小与编译器默认对齐字节数（通常是 4 字节）中较小值的倍数。
例如，在 32 位系统上，int 类型的大小通常是 4 字节，而双精度浮点型的大小通常是 8 字节，
那么一个结构体中有一个 int 类型的成员变量和一个双精度浮点型的成员变量，
编译器可能就会在 int 变量后面补齐 4 个字节，以保证下一个成员变量从 8 字节边界开始存储，
从而提高读写速度和效率。
总之，内存对齐是为了优化 CPU 访问数据的效率和正确性，
而对于为了对齐而填充的字节，则是为了保证成员变量在内存中存储的正确性和访问效率。



逐段对齐
是指编译器在将结构体的成员分配到内存中时，按照一定规则进行对齐。
其主要目的是为了提高 CPU 访问内存的效率，避免因为未对齐而导致的性能下降和错误。
逐段对齐的规则如下：

    1、每个成员的偏移量都必须是该成员大小的整数倍。
    2、结构体的总大小必须是最大基本数据类型的整数倍。
        例如，在 32 位系统中，double 类型是最大的基本数据类型，
        因此结构体的大小应为 8 的整数倍。
    3、编译器可能会在成员之间添加空白字节，以便满足对齐要求。
    4、可以使用 #pragma pack 等指令来控制结构体的对齐方式，
        但这也可能会降低程序的可移植性。

*/

// 逐段对齐
typedef struct stu1
{
    char sex;
    short num;
    int age;
}stu1;	// 1 2补1 + 4 =8

typedef struct stu2
{
    char sex;
    int age;
    short num;
}stu2;	//1补3 + 4 + 2补2 =12  	


// 带位数指定的 逐段对齐
struct s
{
    int i: 8; //占int型里的8位
    int j: 4; //占int型里的4位
    double b; //8字节 8*8
    int a:3;
}s1;
/*
i + j = 12 bit --> 16 bit = 2 byte
b = 8 byte
a = 3 bit ---> 8bit = 1 byte
2+8+1 = 11 byte
由于逐段对齐的规则，
实际上 s1 的大小应该是能够整除最大基本数据类型
（即 double 类型）的最小容量，也就是 24 个字节。


*/



int main(){
  stu s={1,5};
  //问题：如不对齐，长度为5, 取age数据，需要读两次的数据来拼接。
  printf("%d\n",s.age);
  //字节对齐：补空成，类型最大的元素 的整数倍 -> 空间换时间(避免读两次来拼接数据)
  //          sex 补齐3个char 与int想等对齐后，只需读一次 
  printf("%d\n",sizeof(stu));  //8 
  printf("%d\n",sizeof(stu1));  //8 
  printf("%d\n",sizeof(stu2));  //12

  printf("sizeof(s1)= %d\n", sizeof(struct s));//24
  return 0;
}