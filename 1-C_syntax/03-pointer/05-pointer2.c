#include <stdio.h>

int main(int argc, char const *argv[])
{
    printf("指针的写--------------------------------------\n");
    int *pt = NULL; // 写 指针指向的空间
                    //*(pt+1)=3: 对未知的空间赋值，风险大,可能段错误
    int *qt = NULL;
    int x = 9;
    qt = &x;
    pt = qt; // 写 指针(指向相同空间)
    printf("%x  %x \n", *qt, *pt);

    printf("类型转换--------------------------------------\n");

    int num = 12345;
    int *p = &num;
    char *cp = NULL;
    cp = (char *)p;
    printf("%x  %x\n", *p, *cp);
    printf("%d  %d\n", *p, *cp); // 12345  57
    /*
        12345=0011000000111001
            57=00111001
        4个字节 和 1个字节
        由于强制转换的过程中，将整型变量 num 的地址强制转换为字符型指针 cp，
        因此在后续操作中，cp 指向的内存空间将被视为一个字符型变量，其大小为一个字节。
        因此，如果通过 cp 指针访问 num 中的数据，将会得到 num 的最低有效字节的 ASCII 码值，
        因为在大多数计算机系统中，字节序是小端序 (Little Endian) 的。
        例如，如果 num 的值为 12345，即 0x00003039，而计算机采用的是小端序，
        则 cp 指向的内存空间中的数据为 0x39，对应的 ASCII 码值为字符 '9'。
    */

    char *cp2 = NULL;
    char c = 'a';
    cp2 = &c;
    int *p2 = NULL;
    p2 = (int *)cp2;
    printf("%x %x", *cp2, *p2); // 61 303961
    /*
        是的，*p2 的值为 303961，其中 3039 是内存中的其他值，是不确定的。
        由于将 char 型指针 cp2 转换为 int 型指针 p2 后，
        将其指向的内存地址视为一个 int 型变量的地址，而 int 型变量
        通常会占用 4 个字节的内存空间，因此在打印 *p2 时输出了这 4 个字节的内容，
        其中包括了 *cp2 指向的地址处的字节和其后面的 3 个字节。
        但是，在这 4 个字节中哪些是有效数据，哪些是垃圾数据，
        取决于编译器、操作系统和硬件等因素的具体实现。
        因此，程序输出的 *p2 的值是不确定的，
        可能会因为不同的平台和编译器而有所不同。
    */

    return 0;
}
